"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: account/v2/token_info.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenInfo = exports.TokenType = exports.SystemType = exports.protobufPackage = void 0;
exports.systemTypeFromJSON = systemTypeFromJSON;
exports.systemTypeToJSON = systemTypeToJSON;
exports.tokenTypeFromJSON = tokenTypeFromJSON;
exports.tokenTypeToJSON = tokenTypeToJSON;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const timestamp_1 = require("../../google/protobuf/timestamp");
exports.protobufPackage = "account.v2";
/** TODO - Move this to own file */
var SystemType;
(function (SystemType) {
    SystemType[SystemType["SYSTEM_TYPE_UNSPECIFIED"] = 0] = "SYSTEM_TYPE_UNSPECIFIED";
    SystemType[SystemType["SYSTEM_TYPE_WUP"] = 1] = "SYSTEM_TYPE_WUP";
    SystemType[SystemType["SYSTEM_TYPE_CTR"] = 2] = "SYSTEM_TYPE_CTR";
    SystemType[SystemType["SYSTEM_TYPE_API"] = 3] = "SYSTEM_TYPE_API";
    SystemType[SystemType["SYSTEM_TYPE_PASSWORD_RESET"] = 255] = "SYSTEM_TYPE_PASSWORD_RESET";
    SystemType[SystemType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SystemType || (exports.SystemType = SystemType = {}));
function systemTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "SYSTEM_TYPE_UNSPECIFIED":
            return SystemType.SYSTEM_TYPE_UNSPECIFIED;
        case 1:
        case "SYSTEM_TYPE_WUP":
            return SystemType.SYSTEM_TYPE_WUP;
        case 2:
        case "SYSTEM_TYPE_CTR":
            return SystemType.SYSTEM_TYPE_CTR;
        case 3:
        case "SYSTEM_TYPE_API":
            return SystemType.SYSTEM_TYPE_API;
        case 255:
        case "SYSTEM_TYPE_PASSWORD_RESET":
            return SystemType.SYSTEM_TYPE_PASSWORD_RESET;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SystemType.UNRECOGNIZED;
    }
}
function systemTypeToJSON(object) {
    switch (object) {
        case SystemType.SYSTEM_TYPE_UNSPECIFIED:
            return "SYSTEM_TYPE_UNSPECIFIED";
        case SystemType.SYSTEM_TYPE_WUP:
            return "SYSTEM_TYPE_WUP";
        case SystemType.SYSTEM_TYPE_CTR:
            return "SYSTEM_TYPE_CTR";
        case SystemType.SYSTEM_TYPE_API:
            return "SYSTEM_TYPE_API";
        case SystemType.SYSTEM_TYPE_PASSWORD_RESET:
            return "SYSTEM_TYPE_PASSWORD_RESET";
        case SystemType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/** TODO - Move this to own file */
var TokenType;
(function (TokenType) {
    TokenType[TokenType["TOKEN_TYPE_UNSPECIFIED"] = 0] = "TOKEN_TYPE_UNSPECIFIED";
    TokenType[TokenType["TOKEN_TYPE_OAUTH_ACCESS"] = 1] = "TOKEN_TYPE_OAUTH_ACCESS";
    TokenType[TokenType["TOKEN_TYPE_OAUTH_REFRESH"] = 2] = "TOKEN_TYPE_OAUTH_REFRESH";
    TokenType[TokenType["TOKEN_TYPE_NEX"] = 3] = "TOKEN_TYPE_NEX";
    TokenType[TokenType["TOKEN_TYPE_INDEPENDENT_SERVICE"] = 4] = "TOKEN_TYPE_INDEPENDENT_SERVICE";
    TokenType[TokenType["TOKEN_TYPE_PASSWORD_RESET"] = 5] = "TOKEN_TYPE_PASSWORD_RESET";
    TokenType[TokenType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TokenType || (exports.TokenType = TokenType = {}));
function tokenTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "TOKEN_TYPE_UNSPECIFIED":
            return TokenType.TOKEN_TYPE_UNSPECIFIED;
        case 1:
        case "TOKEN_TYPE_OAUTH_ACCESS":
            return TokenType.TOKEN_TYPE_OAUTH_ACCESS;
        case 2:
        case "TOKEN_TYPE_OAUTH_REFRESH":
            return TokenType.TOKEN_TYPE_OAUTH_REFRESH;
        case 3:
        case "TOKEN_TYPE_NEX":
            return TokenType.TOKEN_TYPE_NEX;
        case 4:
        case "TOKEN_TYPE_INDEPENDENT_SERVICE":
            return TokenType.TOKEN_TYPE_INDEPENDENT_SERVICE;
        case 5:
        case "TOKEN_TYPE_PASSWORD_RESET":
            return TokenType.TOKEN_TYPE_PASSWORD_RESET;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TokenType.UNRECOGNIZED;
    }
}
function tokenTypeToJSON(object) {
    switch (object) {
        case TokenType.TOKEN_TYPE_UNSPECIFIED:
            return "TOKEN_TYPE_UNSPECIFIED";
        case TokenType.TOKEN_TYPE_OAUTH_ACCESS:
            return "TOKEN_TYPE_OAUTH_ACCESS";
        case TokenType.TOKEN_TYPE_OAUTH_REFRESH:
            return "TOKEN_TYPE_OAUTH_REFRESH";
        case TokenType.TOKEN_TYPE_NEX:
            return "TOKEN_TYPE_NEX";
        case TokenType.TOKEN_TYPE_INDEPENDENT_SERVICE:
            return "TOKEN_TYPE_INDEPENDENT_SERVICE";
        case TokenType.TOKEN_TYPE_PASSWORD_RESET:
            return "TOKEN_TYPE_PASSWORD_RESET";
        case TokenType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseTokenInfo() {
    return {
        systemType: 0,
        tokenType: 0,
        pid: 0n,
        accessLevel: 0,
        titleId: 0n,
        issueTime: undefined,
        expireTime: undefined,
    };
}
exports.TokenInfo = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.systemType !== 0) {
            writer.uint32(8).int32(message.systemType);
        }
        if (message.tokenType !== 0) {
            writer.uint32(16).int32(message.tokenType);
        }
        if (message.pid !== 0n) {
            if (BigInt.asUintN(64, message.pid) !== message.pid) {
                throw new globalThis.Error("value provided for field message.pid of type uint64 too large");
            }
            writer.uint32(24).uint64(message.pid);
        }
        if (message.accessLevel !== 0) {
            writer.uint32(32).int32(message.accessLevel);
        }
        if (message.titleId !== 0n) {
            if (BigInt.asUintN(64, message.titleId) !== message.titleId) {
                throw new globalThis.Error("value provided for field message.titleId of type uint64 too large");
            }
            writer.uint32(40).uint64(message.titleId);
        }
        if (message.issueTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.issueTime), writer.uint32(50).fork()).join();
        }
        if (message.expireTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(58).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.systemType = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.tokenType = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.pid = reader.uint64();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.accessLevel = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.titleId = reader.uint64();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.issueTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.expireTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            systemType: isSet(object.systemType) ? systemTypeFromJSON(object.systemType) : 0,
            tokenType: isSet(object.tokenType) ? tokenTypeFromJSON(object.tokenType) : 0,
            pid: isSet(object.pid) ? BigInt(object.pid) : 0n,
            accessLevel: isSet(object.accessLevel) ? globalThis.Number(object.accessLevel) : 0,
            titleId: isSet(object.titleId) ? BigInt(object.titleId) : 0n,
            issueTime: isSet(object.issueTime) ? fromJsonTimestamp(object.issueTime) : undefined,
            expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.systemType !== 0) {
            obj.systemType = systemTypeToJSON(message.systemType);
        }
        if (message.tokenType !== 0) {
            obj.tokenType = tokenTypeToJSON(message.tokenType);
        }
        if (message.pid !== 0n) {
            obj.pid = message.pid.toString();
        }
        if (message.accessLevel !== 0) {
            obj.accessLevel = Math.round(message.accessLevel);
        }
        if (message.titleId !== 0n) {
            obj.titleId = message.titleId.toString();
        }
        if (message.issueTime !== undefined) {
            obj.issueTime = message.issueTime.toISOString();
        }
        if (message.expireTime !== undefined) {
            obj.expireTime = message.expireTime.toISOString();
        }
        return obj;
    },
    create(base) {
        return exports.TokenInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTokenInfo();
        message.systemType = object.systemType ?? 0;
        message.tokenType = object.tokenType ?? 0;
        message.pid = object.pid ?? 0n;
        message.accessLevel = object.accessLevel ?? 0;
        message.titleId = object.titleId ?? 0n;
        message.issueTime = object.issueTime ?? undefined;
        message.expireTime = object.expireTime ?? undefined;
        return message;
    },
};
function toTimestamp(date) {
    const seconds = BigInt(Math.trunc(date.getTime() / 1000));
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (globalThis.Number(t.seconds.toString()) || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
